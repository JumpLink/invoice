extends ./layout

block styles
  link(rel="stylesheet", media="screen, print, handheld, projection", type="text/css" href="styles/importer.css")
block body
  #odf

block scripts
  script(src='third-party/webodf/webodf-debug.js', type='text/javascript', charset='utf-8')
  script(type='text/javascript', charset='utf-8').

    // source: http://www.w3schools.com/dom/dom_loadxmldoc.asp
    function loadXMLString(txt) {
      if (window.DOMParser) {
        parser=new DOMParser();
        xmlDoc=parser.parseFromString(txt,"text/xml");
      } else { // code for IE
        xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
        xmlDoc.async=false;
        xmlDoc.loadXML(txt);
      }
      return xmlDoc;
    }

    /*
     * Request to server with file stream of the document.
     */
    var writeFile = function(folder, filename, type, data, callback) {
      if (window.File && window.FileReader && window.FileList && window.Blob) {
        var path = folder+"/"+filename;
        var blob = new Blob([data.buffer], {type : 'application/vnd.oasis.opendocument.'+type});
        var formData = new FormData();
        formData.append("WebODF", blob, filename);

        var request = new XMLHttpRequest();
        request.open("PUT", path);
        request.send(formData);
      } else {
        callback('The File APIs are not fully supported in this browser.');
      }
    }

    /*
     * Save document on server.
     */
    var saveAs = function(odfContainer, folder, filename, callback) {
      odfContainer.createByteArray(function(data) {
        writeFile(folder, filename, odfContainer.getDocumentType(), data, callback)
      }, callback);
    }

    /*
     * Get all custom user field variables and inputs.
     * return: Object {get: array of custom user field variables, decl: array of custom user field inputs}
     */
    var getUserFieldElements = function (odfParentNode, callback) {
      var textns = "urn:oasis:names:tc:opendocument:xmlns:text:1.0";
      var userFieldsGet = odfParentNode.getElementsByTagNameNS(textns, 'user-field-get');
      //- var userFieldsDecl = odfParentNode.getElementsByTagNameNS(textns, 'user-field-decl');
      var userFieldsDecl = odfParentNode.getElementsByTagNameNS(textns, 'user-field-decls')[0].childNodes;
      if(callback) callback(null, {get: UserFieldsGet, decl: UserFieldsDecl});
      return {get: userFieldsGet, decl: userFieldsDecl};
    }

    var createAndAppendUserFieldNodeElement = function (odfContent, name, value, type) {
      var textns = "urn:oasis:names:tc:opendocument:xmlns:text:1.0";
      var userFieldsDecls = odfContent.getElementsByTagNameNS(textns, 'user-field-decls')[0];
      var newElement = document.createElementNS(textns, 'text:user-field-decl');
      newElement.setAttribute('office:value-type', type); // float
      switch(type) {
        case 'float':
          newElement.setAttribute('office:value', value);
        break;
        case 'string':
        case 'time':
        default: // TODO test more types
          newElement.setAttribute('office:'+type+'-value', value);
        break;
      }
      newElement.setAttribute('text:name', name);
      userFieldsDecls.appendChild(newElement);
      return newElement;
    }

    //- var foundOneByAttibute = function (arrayOfElements, attributename, value) {
    //-   for (var i = 0; i < arrayOfElements.length; i++) {
    //-     var element = arrayOfElements[i];
    //-     var currentName = element.getAttribute(attributename);
    //-     if(currentName === value) {
    //-       return element;
    //-     }
    //-   };
    //-   return null;
    //- }

    //- var foundAllByAttibute = function (arrayOfElements, attributename, value) {
    //-   var result = [];
    //-   for (var i = 0; i < arrayOfElements.length; i++) {
    //-     var element = arrayOfElements[i];
    //-     var currentName = element.getAttribute(attributename);
    //-     if(currentName === value) {
    //-       result.push(element)
    //-     }
    //-   };
    //-   return result;
    //- }

    var updateRenameUserFieldGetElement = function (userFieldGetNodes, name, newname, value, callback) {
      var error;

      for (var i = 0; i < userFieldGetNodes.length; i++) {
        var element = userFieldGetNodes[i];
        var currentName = element.getAttribute('text:name');
        if(currentName === name) {
          element.textContent = value;
          element.setAttribute('text:name', newname);
        }
      };

      if(callback) callback(error, userFieldGetNodes);
      return error;
    }

    var updateUserFieldGetElement = function (userFieldGetNodes, name, value, callback) {
      var error;

      for (var i = 0; i < userFieldGetNodes.length; i++) {
        var element = userFieldGetNodes[i];
        var currentName = element.getAttribute('text:name');
        if(currentName === name) {
          element.textContent = value;
        }
      };

      if(callback) callback(error, userFieldGetNodes);
      return error;
    }

    var updateUserFieldDeclElement = function (userFieldDeclNodes, name, type, value, callback) {
      var error, notFound = true;
      for (var i = 0; i < userFieldDeclNodes.length; i++) {
        var element = userFieldDeclNodes[i];
        var currentName = element.getAttribute('text:name');
        var currentType = element.getAttribute('office:value-type');
        if(currentName === name) {
          notFound = false;
          if(currentType === type) {
            switch(type) {
              case 'float':
                element.setAttribute('office:value', value);
              break;
              case 'string':
              case 'time':
              default: // TODO test more types
                element.setAttribute('office:'+type+'-value', value);
              break;
            }
          } else {
            error = "wrong type";
            if(callback) callback(error);
            return error;
          }
        }
      };

      if(notFound) {
        error = "not found";
        if(callback) callback(error);
        return error;
      }

      if(callback) callback(error, userFieldDeclNodes);

    }

    /*
     * Update custom user field variables.
     * This function updates the variable and inputs found in userFieldNodes
     */
    var updateUserFieldElement = function (userFieldNodes, name, type, value, callback) {
      var error, notFound = true;
      updateUserFieldDeclElement(userFieldNodes.decl, name, type, value, function(error, userFieldDeclNodes){
        if(error) {
          if(callback) callback(error);
          return error;
        }
        updateUserFieldGetElement(userFieldNodes.get, name, value, function(error, userFieldGetNodes) {
          if(error) {
            if(callback) callback(error);
            return error;
          }
          callback(error, {get: userFieldGetNodes, decl: userFieldDeclNodes});
        });
      });
    }

    /*
     * Get all tables from parent node
     * return: array of table nodes
     */
    var getTables = function(odfParentNode, callback) {
      var tablens = 'urn:oasis:names:tc:opendocument:xmlns:table:1.0';
      var tables = odfParentNode.getElementsByTagNameNS(tablens, 'table');
      if(callback) callback(null, tables);
      return tables;
    }

    /*
     * Get table node by table name.
     * Required: array of table nodes
     */
    var getTableByName = function(tables, name, callback) {
      var error, notFound = true;
      for (var i = 0; i < tables.length; i++) {
        var element = tables[i];
        var currentName = element.getAttribute('table:name');
        if(currentName === name) {
          notFound = false;
          callback(error, element);
          return error;
        }
      };
      if(notFound) {
        error = "not found";
        callback(error);
        return error;
      }
    }

    /*
     * Custom insertAfter function as a contrast to the native insertBefore method
     * source: http://blog.svidgen.com/2007/10/javascript-insertafter.html
     */
    var insertAfter = function (new_node, existing_node) {
      // if the existing node has a following sibling, insert the current
      // node before it. otherwise appending it to the parent node
      // will correctly place it just after the existing node.
      if (existing_node.nextSibling) {
        // there is a next sibling. insert before it using the mutual
        // parent's insertBefore() method.
        existing_node.parentNode.insertBefore(new_node, existing_node.nextSibling);
      } else {
        // there is no next sibling. append to the end of sthe parent's
        // node list.
        existing_node.parentNode.appendChild(new_node);
      }
    }

    var appendNewTaskTableElement = function (odfContentElement, templateElement, number, title, description, cost) {
    var textns = "urn:oasis:names:tc:opendocument:xmlns:text:1.0";
      var newTableElement = templateElement.cloneNode(true);
      var newTableUserFieldsGet = newTableElement.getElementsByTagNameNS(textns, 'user-field-get');
      newTableElement.setAttribute('table:name', 'tasktable.'+number);

      // create new custom user field for number
      createAndAppendUserFieldNodeElement(odfContentElement, "invoice.task."+number+".number", number, "float");
      // rename old custom user field to new created
      updateRenameUserFieldGetElement(newTableUserFieldsGet, "invoice.task.number", "invoice.task."+number+".number", number);

      // for title
      createAndAppendUserFieldNodeElement(odfContentElement, "invoice.task."+number+".title", title, "string");
      updateRenameUserFieldGetElement(newTableUserFieldsGet, "invoice.task.title", "invoice.task."+number+".title", title);

      // for description
      createAndAppendUserFieldNodeElement(odfContentElement, "invoice.task."+number+".description", description, "string");
      updateRenameUserFieldGetElement(newTableUserFieldsGet, "invoice.task.description", "invoice.task."+number+".description", description);

      // for cost
      createAndAppendUserFieldNodeElement(odfContentElement, "invoice.task."+number+".cost", cost, "string");
      updateRenameUserFieldGetElement(newTableUserFieldsGet, "invoice.task.cost", "invoice.task."+number+".cost", cost);

      odfContentElement.insertBefore(newTableElement, templateElement);
    }

    var odfElement = document.getElementById("odf");
    var odfCanvas = new odf.OdfCanvas(odfElement);
    odfCanvas.load("invoice.odt");

    // Callback fired after odf document is ready
    odfCanvas.addListener("statereadychange", function () {
      var odfContainer = odfCanvas.odfContainer();
      //- var odfElement = odfCanvas.getElement();
      //- var odfDocument = odfElement.getElementsByTagName('document')[0];
      var odfContentElement = odfContainer.getContentElement();
      var zoomHelper = odfCanvas.getZoomHelper();
      zoomHelper.setZoomLevel(0.8);

      var userFieldNodes = getUserFieldElements(odfContentElement);
      updateUserFieldElement(userFieldNodes, 'invoice.currency', 'string', 'Euro', function(error) {
        if(error) console.log(error);
      });

      var tables = getTables(odfContentElement);
      getTableByName(tables, 'tasktable', function(error, tableElement) {
        for (var i = 1; i <= 6; i++) {
          appendNewTaskTableElement(odfContentElement, tableElement, i, "neuer Titel", "neue Beschreibung", 100);
        };
        // remove template
        tableElement.parentNode.removeChild(tableElement);
      });

      odfCanvas.refreshSize();

      saveAs(odfContainer, "odf", "new.odt", function(error) {
        if(error) console.log(error);
      });
    });
